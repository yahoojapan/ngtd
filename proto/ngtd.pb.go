// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: proto/ngtd.proto

/*
	Package ngtd is a generated protocol buffer package.

	It is generated from these files:
		proto/ngtd.proto

	It has these top-level messages:
		Empty
		SearchRequest
		ObjectDistance
		SearchResponse
		InsertRequest
		InsertResponse
		RemoveRequest
		RemoveResponse
		CreateIndexRequest
		GetDimensionResponse
*/
package ngtd

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type Empty struct {
}

func (m *Empty) Reset()                    { *m = Empty{} }
func (m *Empty) String() string            { return proto.CompactTextString(m) }
func (*Empty) ProtoMessage()               {}
func (*Empty) Descriptor() ([]byte, []int) { return fileDescriptorNgtd, []int{0} }

type SearchRequest struct {
	Vector  []float64 `protobuf:"fixed64,1,rep,packed,name=vector" json:"vector,omitempty"`
	Id      []byte    `protobuf:"bytes,2,opt,name=id,proto3" json:"id,omitempty"`
	Size_   int32     `protobuf:"varint,10,opt,name=size,proto3" json:"size,omitempty"`
	Epsilon float32   `protobuf:"fixed32,11,opt,name=epsilon,proto3" json:"epsilon,omitempty"`
}

func (m *SearchRequest) Reset()                    { *m = SearchRequest{} }
func (m *SearchRequest) String() string            { return proto.CompactTextString(m) }
func (*SearchRequest) ProtoMessage()               {}
func (*SearchRequest) Descriptor() ([]byte, []int) { return fileDescriptorNgtd, []int{1} }

func (m *SearchRequest) GetVector() []float64 {
	if m != nil {
		return m.Vector
	}
	return nil
}

func (m *SearchRequest) GetId() []byte {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *SearchRequest) GetSize_() int32 {
	if m != nil {
		return m.Size_
	}
	return 0
}

func (m *SearchRequest) GetEpsilon() float32 {
	if m != nil {
		return m.Epsilon
	}
	return 0
}

type ObjectDistance struct {
	Id       []byte  `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Distance float32 `protobuf:"fixed32,10,opt,name=distance,proto3" json:"distance,omitempty"`
	Error    string  `protobuf:"bytes,99,opt,name=error,proto3" json:"error,omitempty"`
}

func (m *ObjectDistance) Reset()                    { *m = ObjectDistance{} }
func (m *ObjectDistance) String() string            { return proto.CompactTextString(m) }
func (*ObjectDistance) ProtoMessage()               {}
func (*ObjectDistance) Descriptor() ([]byte, []int) { return fileDescriptorNgtd, []int{2} }

func (m *ObjectDistance) GetId() []byte {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *ObjectDistance) GetDistance() float32 {
	if m != nil {
		return m.Distance
	}
	return 0
}

func (m *ObjectDistance) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

type SearchResponse struct {
	Result []*ObjectDistance `protobuf:"bytes,1,rep,name=result" json:"result,omitempty"`
	Error  string            `protobuf:"bytes,99,opt,name=error,proto3" json:"error,omitempty"`
}

func (m *SearchResponse) Reset()                    { *m = SearchResponse{} }
func (m *SearchResponse) String() string            { return proto.CompactTextString(m) }
func (*SearchResponse) ProtoMessage()               {}
func (*SearchResponse) Descriptor() ([]byte, []int) { return fileDescriptorNgtd, []int{3} }

func (m *SearchResponse) GetResult() []*ObjectDistance {
	if m != nil {
		return m.Result
	}
	return nil
}

func (m *SearchResponse) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

type InsertRequest struct {
	Vector []float64 `protobuf:"fixed64,1,rep,packed,name=vector" json:"vector,omitempty"`
	Id     []byte    `protobuf:"bytes,2,opt,name=id,proto3" json:"id,omitempty"`
}

func (m *InsertRequest) Reset()                    { *m = InsertRequest{} }
func (m *InsertRequest) String() string            { return proto.CompactTextString(m) }
func (*InsertRequest) ProtoMessage()               {}
func (*InsertRequest) Descriptor() ([]byte, []int) { return fileDescriptorNgtd, []int{4} }

func (m *InsertRequest) GetVector() []float64 {
	if m != nil {
		return m.Vector
	}
	return nil
}

func (m *InsertRequest) GetId() []byte {
	if m != nil {
		return m.Id
	}
	return nil
}

type InsertResponse struct {
	Error string `protobuf:"bytes,99,opt,name=error,proto3" json:"error,omitempty"`
}

func (m *InsertResponse) Reset()                    { *m = InsertResponse{} }
func (m *InsertResponse) String() string            { return proto.CompactTextString(m) }
func (*InsertResponse) ProtoMessage()               {}
func (*InsertResponse) Descriptor() ([]byte, []int) { return fileDescriptorNgtd, []int{5} }

func (m *InsertResponse) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

type RemoveRequest struct {
	Id []byte `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
}

func (m *RemoveRequest) Reset()                    { *m = RemoveRequest{} }
func (m *RemoveRequest) String() string            { return proto.CompactTextString(m) }
func (*RemoveRequest) ProtoMessage()               {}
func (*RemoveRequest) Descriptor() ([]byte, []int) { return fileDescriptorNgtd, []int{6} }

func (m *RemoveRequest) GetId() []byte {
	if m != nil {
		return m.Id
	}
	return nil
}

type RemoveResponse struct {
	Error string `protobuf:"bytes,99,opt,name=error,proto3" json:"error,omitempty"`
}

func (m *RemoveResponse) Reset()                    { *m = RemoveResponse{} }
func (m *RemoveResponse) String() string            { return proto.CompactTextString(m) }
func (*RemoveResponse) ProtoMessage()               {}
func (*RemoveResponse) Descriptor() ([]byte, []int) { return fileDescriptorNgtd, []int{7} }

func (m *RemoveResponse) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

type CreateIndexRequest struct {
	PoolSize uint32 `protobuf:"varint,1,opt,name=pool_size,json=poolSize,proto3" json:"pool_size,omitempty"`
}

func (m *CreateIndexRequest) Reset()                    { *m = CreateIndexRequest{} }
func (m *CreateIndexRequest) String() string            { return proto.CompactTextString(m) }
func (*CreateIndexRequest) ProtoMessage()               {}
func (*CreateIndexRequest) Descriptor() ([]byte, []int) { return fileDescriptorNgtd, []int{8} }

func (m *CreateIndexRequest) GetPoolSize() uint32 {
	if m != nil {
		return m.PoolSize
	}
	return 0
}

type GetDimensionResponse struct {
	Dimension int32 `protobuf:"varint,1,opt,name=dimension,proto3" json:"dimension,omitempty"`
}

func (m *GetDimensionResponse) Reset()                    { *m = GetDimensionResponse{} }
func (m *GetDimensionResponse) String() string            { return proto.CompactTextString(m) }
func (*GetDimensionResponse) ProtoMessage()               {}
func (*GetDimensionResponse) Descriptor() ([]byte, []int) { return fileDescriptorNgtd, []int{9} }

func (m *GetDimensionResponse) GetDimension() int32 {
	if m != nil {
		return m.Dimension
	}
	return 0
}

func init() {
	proto.RegisterType((*Empty)(nil), "ngtd.Empty")
	proto.RegisterType((*SearchRequest)(nil), "ngtd.SearchRequest")
	proto.RegisterType((*ObjectDistance)(nil), "ngtd.ObjectDistance")
	proto.RegisterType((*SearchResponse)(nil), "ngtd.SearchResponse")
	proto.RegisterType((*InsertRequest)(nil), "ngtd.InsertRequest")
	proto.RegisterType((*InsertResponse)(nil), "ngtd.InsertResponse")
	proto.RegisterType((*RemoveRequest)(nil), "ngtd.RemoveRequest")
	proto.RegisterType((*RemoveResponse)(nil), "ngtd.RemoveResponse")
	proto.RegisterType((*CreateIndexRequest)(nil), "ngtd.CreateIndexRequest")
	proto.RegisterType((*GetDimensionResponse)(nil), "ngtd.GetDimensionResponse")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for NGTD service

type NGTDClient interface {
	Search(ctx context.Context, in *SearchRequest, opts ...grpc.CallOption) (*SearchResponse, error)
	SearchByID(ctx context.Context, in *SearchRequest, opts ...grpc.CallOption) (*SearchResponse, error)
	StreamSearch(ctx context.Context, opts ...grpc.CallOption) (NGTD_StreamSearchClient, error)
	StreamSearchByID(ctx context.Context, opts ...grpc.CallOption) (NGTD_StreamSearchByIDClient, error)
	Insert(ctx context.Context, in *InsertRequest, opts ...grpc.CallOption) (*InsertResponse, error)
	StreamInsert(ctx context.Context, opts ...grpc.CallOption) (NGTD_StreamInsertClient, error)
	Remove(ctx context.Context, in *RemoveRequest, opts ...grpc.CallOption) (*RemoveResponse, error)
	StreamRemove(ctx context.Context, opts ...grpc.CallOption) (NGTD_StreamRemoveClient, error)
	CreateIndex(ctx context.Context, in *CreateIndexRequest, opts ...grpc.CallOption) (*Empty, error)
	SaveIndex(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error)
	GetDimension(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*GetDimensionResponse, error)
}

type nGTDClient struct {
	cc *grpc.ClientConn
}

func NewNGTDClient(cc *grpc.ClientConn) NGTDClient {
	return &nGTDClient{cc}
}

func (c *nGTDClient) Search(ctx context.Context, in *SearchRequest, opts ...grpc.CallOption) (*SearchResponse, error) {
	out := new(SearchResponse)
	err := grpc.Invoke(ctx, "/ngtd.NGTD/Search", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nGTDClient) SearchByID(ctx context.Context, in *SearchRequest, opts ...grpc.CallOption) (*SearchResponse, error) {
	out := new(SearchResponse)
	err := grpc.Invoke(ctx, "/ngtd.NGTD/SearchByID", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nGTDClient) StreamSearch(ctx context.Context, opts ...grpc.CallOption) (NGTD_StreamSearchClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_NGTD_serviceDesc.Streams[0], c.cc, "/ngtd.NGTD/StreamSearch", opts...)
	if err != nil {
		return nil, err
	}
	x := &nGTDStreamSearchClient{stream}
	return x, nil
}

type NGTD_StreamSearchClient interface {
	Send(*SearchRequest) error
	Recv() (*SearchResponse, error)
	grpc.ClientStream
}

type nGTDStreamSearchClient struct {
	grpc.ClientStream
}

func (x *nGTDStreamSearchClient) Send(m *SearchRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *nGTDStreamSearchClient) Recv() (*SearchResponse, error) {
	m := new(SearchResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *nGTDClient) StreamSearchByID(ctx context.Context, opts ...grpc.CallOption) (NGTD_StreamSearchByIDClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_NGTD_serviceDesc.Streams[1], c.cc, "/ngtd.NGTD/StreamSearchByID", opts...)
	if err != nil {
		return nil, err
	}
	x := &nGTDStreamSearchByIDClient{stream}
	return x, nil
}

type NGTD_StreamSearchByIDClient interface {
	Send(*SearchRequest) error
	Recv() (*SearchResponse, error)
	grpc.ClientStream
}

type nGTDStreamSearchByIDClient struct {
	grpc.ClientStream
}

func (x *nGTDStreamSearchByIDClient) Send(m *SearchRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *nGTDStreamSearchByIDClient) Recv() (*SearchResponse, error) {
	m := new(SearchResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *nGTDClient) Insert(ctx context.Context, in *InsertRequest, opts ...grpc.CallOption) (*InsertResponse, error) {
	out := new(InsertResponse)
	err := grpc.Invoke(ctx, "/ngtd.NGTD/Insert", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nGTDClient) StreamInsert(ctx context.Context, opts ...grpc.CallOption) (NGTD_StreamInsertClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_NGTD_serviceDesc.Streams[2], c.cc, "/ngtd.NGTD/StreamInsert", opts...)
	if err != nil {
		return nil, err
	}
	x := &nGTDStreamInsertClient{stream}
	return x, nil
}

type NGTD_StreamInsertClient interface {
	Send(*InsertRequest) error
	Recv() (*InsertResponse, error)
	grpc.ClientStream
}

type nGTDStreamInsertClient struct {
	grpc.ClientStream
}

func (x *nGTDStreamInsertClient) Send(m *InsertRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *nGTDStreamInsertClient) Recv() (*InsertResponse, error) {
	m := new(InsertResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *nGTDClient) Remove(ctx context.Context, in *RemoveRequest, opts ...grpc.CallOption) (*RemoveResponse, error) {
	out := new(RemoveResponse)
	err := grpc.Invoke(ctx, "/ngtd.NGTD/Remove", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nGTDClient) StreamRemove(ctx context.Context, opts ...grpc.CallOption) (NGTD_StreamRemoveClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_NGTD_serviceDesc.Streams[3], c.cc, "/ngtd.NGTD/StreamRemove", opts...)
	if err != nil {
		return nil, err
	}
	x := &nGTDStreamRemoveClient{stream}
	return x, nil
}

type NGTD_StreamRemoveClient interface {
	Send(*RemoveRequest) error
	Recv() (*RemoveResponse, error)
	grpc.ClientStream
}

type nGTDStreamRemoveClient struct {
	grpc.ClientStream
}

func (x *nGTDStreamRemoveClient) Send(m *RemoveRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *nGTDStreamRemoveClient) Recv() (*RemoveResponse, error) {
	m := new(RemoveResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *nGTDClient) CreateIndex(ctx context.Context, in *CreateIndexRequest, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := grpc.Invoke(ctx, "/ngtd.NGTD/CreateIndex", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nGTDClient) SaveIndex(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := grpc.Invoke(ctx, "/ngtd.NGTD/SaveIndex", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nGTDClient) GetDimension(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*GetDimensionResponse, error) {
	out := new(GetDimensionResponse)
	err := grpc.Invoke(ctx, "/ngtd.NGTD/GetDimension", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for NGTD service

type NGTDServer interface {
	Search(context.Context, *SearchRequest) (*SearchResponse, error)
	SearchByID(context.Context, *SearchRequest) (*SearchResponse, error)
	StreamSearch(NGTD_StreamSearchServer) error
	StreamSearchByID(NGTD_StreamSearchByIDServer) error
	Insert(context.Context, *InsertRequest) (*InsertResponse, error)
	StreamInsert(NGTD_StreamInsertServer) error
	Remove(context.Context, *RemoveRequest) (*RemoveResponse, error)
	StreamRemove(NGTD_StreamRemoveServer) error
	CreateIndex(context.Context, *CreateIndexRequest) (*Empty, error)
	SaveIndex(context.Context, *Empty) (*Empty, error)
	GetDimension(context.Context, *Empty) (*GetDimensionResponse, error)
}

func RegisterNGTDServer(s *grpc.Server, srv NGTDServer) {
	s.RegisterService(&_NGTD_serviceDesc, srv)
}

func _NGTD_Search_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SearchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NGTDServer).Search(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ngtd.NGTD/Search",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NGTDServer).Search(ctx, req.(*SearchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NGTD_SearchByID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SearchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NGTDServer).SearchByID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ngtd.NGTD/SearchByID",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NGTDServer).SearchByID(ctx, req.(*SearchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NGTD_StreamSearch_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(NGTDServer).StreamSearch(&nGTDStreamSearchServer{stream})
}

type NGTD_StreamSearchServer interface {
	Send(*SearchResponse) error
	Recv() (*SearchRequest, error)
	grpc.ServerStream
}

type nGTDStreamSearchServer struct {
	grpc.ServerStream
}

func (x *nGTDStreamSearchServer) Send(m *SearchResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *nGTDStreamSearchServer) Recv() (*SearchRequest, error) {
	m := new(SearchRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _NGTD_StreamSearchByID_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(NGTDServer).StreamSearchByID(&nGTDStreamSearchByIDServer{stream})
}

type NGTD_StreamSearchByIDServer interface {
	Send(*SearchResponse) error
	Recv() (*SearchRequest, error)
	grpc.ServerStream
}

type nGTDStreamSearchByIDServer struct {
	grpc.ServerStream
}

func (x *nGTDStreamSearchByIDServer) Send(m *SearchResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *nGTDStreamSearchByIDServer) Recv() (*SearchRequest, error) {
	m := new(SearchRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _NGTD_Insert_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InsertRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NGTDServer).Insert(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ngtd.NGTD/Insert",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NGTDServer).Insert(ctx, req.(*InsertRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NGTD_StreamInsert_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(NGTDServer).StreamInsert(&nGTDStreamInsertServer{stream})
}

type NGTD_StreamInsertServer interface {
	Send(*InsertResponse) error
	Recv() (*InsertRequest, error)
	grpc.ServerStream
}

type nGTDStreamInsertServer struct {
	grpc.ServerStream
}

func (x *nGTDStreamInsertServer) Send(m *InsertResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *nGTDStreamInsertServer) Recv() (*InsertRequest, error) {
	m := new(InsertRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _NGTD_Remove_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemoveRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NGTDServer).Remove(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ngtd.NGTD/Remove",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NGTDServer).Remove(ctx, req.(*RemoveRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NGTD_StreamRemove_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(NGTDServer).StreamRemove(&nGTDStreamRemoveServer{stream})
}

type NGTD_StreamRemoveServer interface {
	Send(*RemoveResponse) error
	Recv() (*RemoveRequest, error)
	grpc.ServerStream
}

type nGTDStreamRemoveServer struct {
	grpc.ServerStream
}

func (x *nGTDStreamRemoveServer) Send(m *RemoveResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *nGTDStreamRemoveServer) Recv() (*RemoveRequest, error) {
	m := new(RemoveRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _NGTD_CreateIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateIndexRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NGTDServer).CreateIndex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ngtd.NGTD/CreateIndex",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NGTDServer).CreateIndex(ctx, req.(*CreateIndexRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NGTD_SaveIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NGTDServer).SaveIndex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ngtd.NGTD/SaveIndex",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NGTDServer).SaveIndex(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _NGTD_GetDimension_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NGTDServer).GetDimension(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ngtd.NGTD/GetDimension",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NGTDServer).GetDimension(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

var _NGTD_serviceDesc = grpc.ServiceDesc{
	ServiceName: "ngtd.NGTD",
	HandlerType: (*NGTDServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Search",
			Handler:    _NGTD_Search_Handler,
		},
		{
			MethodName: "SearchByID",
			Handler:    _NGTD_SearchByID_Handler,
		},
		{
			MethodName: "Insert",
			Handler:    _NGTD_Insert_Handler,
		},
		{
			MethodName: "Remove",
			Handler:    _NGTD_Remove_Handler,
		},
		{
			MethodName: "CreateIndex",
			Handler:    _NGTD_CreateIndex_Handler,
		},
		{
			MethodName: "SaveIndex",
			Handler:    _NGTD_SaveIndex_Handler,
		},
		{
			MethodName: "GetDimension",
			Handler:    _NGTD_GetDimension_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "StreamSearch",
			Handler:       _NGTD_StreamSearch_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "StreamSearchByID",
			Handler:       _NGTD_StreamSearchByID_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "StreamInsert",
			Handler:       _NGTD_StreamInsert_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "StreamRemove",
			Handler:       _NGTD_StreamRemove_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "proto/ngtd.proto",
}

func (m *Empty) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Empty) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *SearchRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SearchRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Vector) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNgtd(dAtA, i, uint64(len(m.Vector)*8))
		for _, num := range m.Vector {
			f1 := math.Float64bits(float64(num))
			dAtA[i] = uint8(f1)
			i++
			dAtA[i] = uint8(f1 >> 8)
			i++
			dAtA[i] = uint8(f1 >> 16)
			i++
			dAtA[i] = uint8(f1 >> 24)
			i++
			dAtA[i] = uint8(f1 >> 32)
			i++
			dAtA[i] = uint8(f1 >> 40)
			i++
			dAtA[i] = uint8(f1 >> 48)
			i++
			dAtA[i] = uint8(f1 >> 56)
			i++
		}
	}
	if len(m.Id) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintNgtd(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if m.Size_ != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintNgtd(dAtA, i, uint64(m.Size_))
	}
	if m.Epsilon != 0 {
		dAtA[i] = 0x5d
		i++
		i = encodeFixed32Ngtd(dAtA, i, uint32(math.Float32bits(float32(m.Epsilon))))
	}
	return i, nil
}

func (m *ObjectDistance) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ObjectDistance) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNgtd(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if m.Distance != 0 {
		dAtA[i] = 0x55
		i++
		i = encodeFixed32Ngtd(dAtA, i, uint32(math.Float32bits(float32(m.Distance))))
	}
	if len(m.Error) > 0 {
		dAtA[i] = 0x9a
		i++
		dAtA[i] = 0x6
		i++
		i = encodeVarintNgtd(dAtA, i, uint64(len(m.Error)))
		i += copy(dAtA[i:], m.Error)
	}
	return i, nil
}

func (m *SearchResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SearchResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Result) > 0 {
		for _, msg := range m.Result {
			dAtA[i] = 0xa
			i++
			i = encodeVarintNgtd(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Error) > 0 {
		dAtA[i] = 0x9a
		i++
		dAtA[i] = 0x6
		i++
		i = encodeVarintNgtd(dAtA, i, uint64(len(m.Error)))
		i += copy(dAtA[i:], m.Error)
	}
	return i, nil
}

func (m *InsertRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InsertRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Vector) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNgtd(dAtA, i, uint64(len(m.Vector)*8))
		for _, num := range m.Vector {
			f2 := math.Float64bits(float64(num))
			dAtA[i] = uint8(f2)
			i++
			dAtA[i] = uint8(f2 >> 8)
			i++
			dAtA[i] = uint8(f2 >> 16)
			i++
			dAtA[i] = uint8(f2 >> 24)
			i++
			dAtA[i] = uint8(f2 >> 32)
			i++
			dAtA[i] = uint8(f2 >> 40)
			i++
			dAtA[i] = uint8(f2 >> 48)
			i++
			dAtA[i] = uint8(f2 >> 56)
			i++
		}
	}
	if len(m.Id) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintNgtd(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	return i, nil
}

func (m *InsertResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InsertResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Error) > 0 {
		dAtA[i] = 0x9a
		i++
		dAtA[i] = 0x6
		i++
		i = encodeVarintNgtd(dAtA, i, uint64(len(m.Error)))
		i += copy(dAtA[i:], m.Error)
	}
	return i, nil
}

func (m *RemoveRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RemoveRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintNgtd(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	return i, nil
}

func (m *RemoveResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RemoveResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Error) > 0 {
		dAtA[i] = 0x9a
		i++
		dAtA[i] = 0x6
		i++
		i = encodeVarintNgtd(dAtA, i, uint64(len(m.Error)))
		i += copy(dAtA[i:], m.Error)
	}
	return i, nil
}

func (m *CreateIndexRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateIndexRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.PoolSize != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintNgtd(dAtA, i, uint64(m.PoolSize))
	}
	return i, nil
}

func (m *GetDimensionResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetDimensionResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Dimension != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintNgtd(dAtA, i, uint64(m.Dimension))
	}
	return i, nil
}

func encodeFixed64Ngtd(dAtA []byte, offset int, v uint64) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	dAtA[offset+4] = uint8(v >> 32)
	dAtA[offset+5] = uint8(v >> 40)
	dAtA[offset+6] = uint8(v >> 48)
	dAtA[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Ngtd(dAtA []byte, offset int, v uint32) int {
	dAtA[offset] = uint8(v)
	dAtA[offset+1] = uint8(v >> 8)
	dAtA[offset+2] = uint8(v >> 16)
	dAtA[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintNgtd(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Empty) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *SearchRequest) Size() (n int) {
	var l int
	_ = l
	if len(m.Vector) > 0 {
		n += 1 + sovNgtd(uint64(len(m.Vector)*8)) + len(m.Vector)*8
	}
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovNgtd(uint64(l))
	}
	if m.Size_ != 0 {
		n += 1 + sovNgtd(uint64(m.Size_))
	}
	if m.Epsilon != 0 {
		n += 5
	}
	return n
}

func (m *ObjectDistance) Size() (n int) {
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovNgtd(uint64(l))
	}
	if m.Distance != 0 {
		n += 5
	}
	l = len(m.Error)
	if l > 0 {
		n += 2 + l + sovNgtd(uint64(l))
	}
	return n
}

func (m *SearchResponse) Size() (n int) {
	var l int
	_ = l
	if len(m.Result) > 0 {
		for _, e := range m.Result {
			l = e.Size()
			n += 1 + l + sovNgtd(uint64(l))
		}
	}
	l = len(m.Error)
	if l > 0 {
		n += 2 + l + sovNgtd(uint64(l))
	}
	return n
}

func (m *InsertRequest) Size() (n int) {
	var l int
	_ = l
	if len(m.Vector) > 0 {
		n += 1 + sovNgtd(uint64(len(m.Vector)*8)) + len(m.Vector)*8
	}
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovNgtd(uint64(l))
	}
	return n
}

func (m *InsertResponse) Size() (n int) {
	var l int
	_ = l
	l = len(m.Error)
	if l > 0 {
		n += 2 + l + sovNgtd(uint64(l))
	}
	return n
}

func (m *RemoveRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovNgtd(uint64(l))
	}
	return n
}

func (m *RemoveResponse) Size() (n int) {
	var l int
	_ = l
	l = len(m.Error)
	if l > 0 {
		n += 2 + l + sovNgtd(uint64(l))
	}
	return n
}

func (m *CreateIndexRequest) Size() (n int) {
	var l int
	_ = l
	if m.PoolSize != 0 {
		n += 1 + sovNgtd(uint64(m.PoolSize))
	}
	return n
}

func (m *GetDimensionResponse) Size() (n int) {
	var l int
	_ = l
	if m.Dimension != 0 {
		n += 1 + sovNgtd(uint64(m.Dimension))
	}
	return n
}

func sovNgtd(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozNgtd(x uint64) (n int) {
	return sovNgtd(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Empty) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNgtd
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Empty: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Empty: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipNgtd(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNgtd
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SearchRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNgtd
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SearchRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SearchRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				iNdEx += 8
				v = uint64(dAtA[iNdEx-8])
				v |= uint64(dAtA[iNdEx-7]) << 8
				v |= uint64(dAtA[iNdEx-6]) << 16
				v |= uint64(dAtA[iNdEx-5]) << 24
				v |= uint64(dAtA[iNdEx-4]) << 32
				v |= uint64(dAtA[iNdEx-3]) << 40
				v |= uint64(dAtA[iNdEx-2]) << 48
				v |= uint64(dAtA[iNdEx-1]) << 56
				v2 := float64(math.Float64frombits(v))
				m.Vector = append(m.Vector, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNgtd
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthNgtd
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					iNdEx += 8
					v = uint64(dAtA[iNdEx-8])
					v |= uint64(dAtA[iNdEx-7]) << 8
					v |= uint64(dAtA[iNdEx-6]) << 16
					v |= uint64(dAtA[iNdEx-5]) << 24
					v |= uint64(dAtA[iNdEx-4]) << 32
					v |= uint64(dAtA[iNdEx-3]) << 40
					v |= uint64(dAtA[iNdEx-2]) << 48
					v |= uint64(dAtA[iNdEx-1]) << 56
					v2 := float64(math.Float64frombits(v))
					m.Vector = append(m.Vector, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Vector", wireType)
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNgtd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNgtd
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = append(m.Id[:0], dAtA[iNdEx:postIndex]...)
			if m.Id == nil {
				m.Id = []byte{}
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Size_", wireType)
			}
			m.Size_ = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNgtd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Size_ |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Epsilon", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.Epsilon = float32(math.Float32frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipNgtd(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNgtd
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ObjectDistance) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNgtd
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ObjectDistance: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ObjectDistance: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNgtd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNgtd
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = append(m.Id[:0], dAtA[iNdEx:postIndex]...)
			if m.Id == nil {
				m.Id = []byte{}
			}
			iNdEx = postIndex
		case 10:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Distance", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 4
			v = uint32(dAtA[iNdEx-4])
			v |= uint32(dAtA[iNdEx-3]) << 8
			v |= uint32(dAtA[iNdEx-2]) << 16
			v |= uint32(dAtA[iNdEx-1]) << 24
			m.Distance = float32(math.Float32frombits(v))
		case 99:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNgtd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNgtd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNgtd(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNgtd
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SearchResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNgtd
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SearchResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SearchResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNgtd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthNgtd
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Result = append(m.Result, &ObjectDistance{})
			if err := m.Result[len(m.Result)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 99:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNgtd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNgtd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNgtd(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNgtd
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InsertRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNgtd
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InsertRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InsertRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 1 {
				var v uint64
				if (iNdEx + 8) > l {
					return io.ErrUnexpectedEOF
				}
				iNdEx += 8
				v = uint64(dAtA[iNdEx-8])
				v |= uint64(dAtA[iNdEx-7]) << 8
				v |= uint64(dAtA[iNdEx-6]) << 16
				v |= uint64(dAtA[iNdEx-5]) << 24
				v |= uint64(dAtA[iNdEx-4]) << 32
				v |= uint64(dAtA[iNdEx-3]) << 40
				v |= uint64(dAtA[iNdEx-2]) << 48
				v |= uint64(dAtA[iNdEx-1]) << 56
				v2 := float64(math.Float64frombits(v))
				m.Vector = append(m.Vector, v2)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowNgtd
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthNgtd
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					if (iNdEx + 8) > l {
						return io.ErrUnexpectedEOF
					}
					iNdEx += 8
					v = uint64(dAtA[iNdEx-8])
					v |= uint64(dAtA[iNdEx-7]) << 8
					v |= uint64(dAtA[iNdEx-6]) << 16
					v |= uint64(dAtA[iNdEx-5]) << 24
					v |= uint64(dAtA[iNdEx-4]) << 32
					v |= uint64(dAtA[iNdEx-3]) << 40
					v |= uint64(dAtA[iNdEx-2]) << 48
					v |= uint64(dAtA[iNdEx-1]) << 56
					v2 := float64(math.Float64frombits(v))
					m.Vector = append(m.Vector, v2)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Vector", wireType)
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNgtd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNgtd
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = append(m.Id[:0], dAtA[iNdEx:postIndex]...)
			if m.Id == nil {
				m.Id = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNgtd(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNgtd
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InsertResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNgtd
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InsertResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InsertResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 99:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNgtd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNgtd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNgtd(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNgtd
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RemoveRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNgtd
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RemoveRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RemoveRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNgtd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthNgtd
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = append(m.Id[:0], dAtA[iNdEx:postIndex]...)
			if m.Id == nil {
				m.Id = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNgtd(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNgtd
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RemoveResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNgtd
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RemoveResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RemoveResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 99:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNgtd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthNgtd
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipNgtd(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNgtd
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateIndexRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNgtd
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateIndexRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateIndexRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PoolSize", wireType)
			}
			m.PoolSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNgtd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PoolSize |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNgtd(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNgtd
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetDimensionResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowNgtd
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetDimensionResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetDimensionResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dimension", wireType)
			}
			m.Dimension = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowNgtd
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Dimension |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipNgtd(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthNgtd
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipNgtd(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowNgtd
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowNgtd
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowNgtd
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthNgtd
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowNgtd
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipNgtd(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthNgtd = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowNgtd   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("proto/ngtd.proto", fileDescriptorNgtd) }

var fileDescriptorNgtd = []byte{
	// 492 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x54, 0xcd, 0x6e, 0xd3, 0x40,
	0x10, 0xce, 0x9a, 0xd8, 0x6d, 0x26, 0x3f, 0x8a, 0x96, 0x08, 0x59, 0x01, 0x05, 0xcb, 0x07, 0xf0,
	0x01, 0x15, 0x28, 0x14, 0xd4, 0x13, 0x52, 0x1b, 0x54, 0xe5, 0x02, 0xd2, 0xa6, 0x77, 0xe4, 0xda,
	0x23, 0x30, 0x4a, 0xbc, 0x66, 0x77, 0x1b, 0xd1, 0x3e, 0x02, 0x4f, 0xc0, 0x23, 0x71, 0xe4, 0x11,
	0x50, 0x78, 0x11, 0x94, 0x5d, 0x6f, 0xb0, 0x4b, 0xa8, 0x94, 0xdc, 0x76, 0x7e, 0xbe, 0xef, 0x1b,
	0xcf, 0x7c, 0x32, 0xf4, 0x0b, 0xc1, 0x15, 0x7f, 0x9a, 0x7f, 0x54, 0xe9, 0x81, 0x7e, 0xd2, 0xe6,
	0xea, 0x1d, 0xee, 0x81, 0xfb, 0x76, 0x5e, 0xa8, 0xab, 0x10, 0xa1, 0x3b, 0xc5, 0x58, 0x24, 0x9f,
	0x18, 0x7e, 0xb9, 0x44, 0xa9, 0xe8, 0x3d, 0xf0, 0x16, 0x98, 0x28, 0x2e, 0x7c, 0x12, 0xdc, 0x89,
	0x08, 0x2b, 0x23, 0xda, 0x03, 0x27, 0x4b, 0x7d, 0x27, 0x20, 0x51, 0x87, 0x39, 0x59, 0x4a, 0x29,
	0x34, 0x65, 0x76, 0x8d, 0x3e, 0x04, 0x24, 0x72, 0x99, 0x7e, 0x53, 0x1f, 0xf6, 0xb0, 0x90, 0xd9,
	0x8c, 0xe7, 0x7e, 0x3b, 0x20, 0x91, 0xc3, 0x6c, 0x18, 0x32, 0xe8, 0xbd, 0xbf, 0xf8, 0x8c, 0x89,
	0x1a, 0x67, 0x52, 0xc5, 0x79, 0x82, 0x25, 0x1f, 0x59, 0xf3, 0x0d, 0x61, 0x3f, 0x2d, 0x6b, 0x9a,
	0xd3, 0x61, 0xeb, 0x98, 0x0e, 0xc0, 0x45, 0x21, 0xb8, 0xf0, 0x93, 0x80, 0x44, 0x2d, 0x66, 0x82,
	0xf0, 0x1c, 0x7a, 0x76, 0x74, 0x59, 0xf0, 0x5c, 0x22, 0x7d, 0x02, 0x9e, 0x40, 0x79, 0x39, 0x53,
	0x7a, 0xf6, 0xf6, 0xe1, 0xe0, 0x40, 0x7f, 0x78, 0x5d, 0x99, 0x95, 0x3d, 0xff, 0x61, 0x7d, 0x0d,
	0xdd, 0x49, 0x2e, 0x51, 0xa8, 0x2d, 0x17, 0x12, 0x3e, 0x82, 0x9e, 0x05, 0x96, 0xe3, 0x6c, 0x16,
	0x78, 0x08, 0x5d, 0x86, 0x73, 0xbe, 0x40, 0x2b, 0x70, 0x63, 0x13, 0x2b, 0x22, 0xdb, 0x70, 0x2b,
	0xd1, 0x73, 0xa0, 0xa7, 0x02, 0x63, 0x85, 0x93, 0x3c, 0xc5, 0xaf, 0x96, 0xed, 0x3e, 0xb4, 0x0a,
	0xce, 0x67, 0x1f, 0xf4, 0x71, 0x56, 0xa4, 0x5d, 0xb6, 0xbf, 0x4a, 0x4c, 0xb3, 0x6b, 0x0c, 0x5f,
	0xc2, 0xe0, 0x0c, 0xd5, 0x38, 0x9b, 0x63, 0x2e, 0x33, 0x9e, 0xaf, 0x05, 0x1e, 0x40, 0x2b, 0xb5,
	0x49, 0x0d, 0x72, 0xd9, 0xdf, 0xc4, 0xe1, 0x37, 0x17, 0x9a, 0xef, 0xce, 0xce, 0xc7, 0xf4, 0x08,
	0x3c, 0xb3, 0x71, 0x7a, 0xd7, 0x6c, 0xb6, 0x66, 0x9d, 0xe1, 0xa0, 0x9e, 0x34, 0xdc, 0x61, 0x83,
	0x1e, 0x03, 0x98, 0xdc, 0xc9, 0xd5, 0x64, 0xbc, 0x1d, 0xf4, 0x0d, 0x74, 0xa6, 0x4a, 0x60, 0x3c,
	0xdf, 0x41, 0x37, 0x22, 0xcf, 0x08, 0x3d, 0x85, 0x7e, 0x95, 0x60, 0xeb, 0x09, 0x34, 0xc9, 0x11,
	0x78, 0xe6, 0xb4, 0x16, 0x5a, 0x73, 0x88, 0x85, 0xd6, 0xaf, 0x5f, 0x1d, 0x7e, 0x07, 0xb0, 0xd5,
	0x35, 0x4e, 0xb0, 0xd0, 0x9a, 0x71, 0x2c, 0xb4, 0x6e, 0x96, 0xaa, 0xee, 0x0e, 0x60, 0xad, 0xfb,
	0x0a, 0xda, 0x15, 0x67, 0x51, 0xdf, 0xb4, 0xfe, 0x6b, 0xb6, 0x61, 0xdb, 0x54, 0xcc, 0xaf, 0xa4,
	0x41, 0x1f, 0x43, 0x6b, 0x1a, 0x2f, 0x4a, 0x54, 0xb5, 0x76, 0xb3, 0xf1, 0x18, 0x3a, 0x55, 0x1f,
	0xd6, 0x7b, 0x87, 0x26, 0xd8, 0x64, 0xd4, 0xb0, 0x71, 0xd2, 0xff, 0xb1, 0x1c, 0x91, 0x9f, 0xcb,
	0x11, 0xf9, 0xb5, 0x1c, 0x91, 0xef, 0xbf, 0x47, 0x8d, 0x0b, 0x4f, 0xff, 0xd8, 0x5e, 0xfc, 0x09,
	0x00, 0x00, 0xff, 0xff, 0x92, 0xfa, 0xcd, 0x03, 0xec, 0x04, 0x00, 0x00,
}
